//package ttl.larku.dao;
//
//import org.junit.jupiter.api.Test;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.boot.test.context.SpringBootTest;
//import org.springframework.test.annotation.DirtiesContext;
//import org.springframework.test.annotation.DirtiesContext.ClassMode;
//import org.springframework.test.context.jdbc.Sql;
//import ttl.larku.domain.Student;
//import ttl.larku.domain.Student_;
//
//import jakarta.persistence.EntityManager;
//import jakarta.persistence.PersistenceContext;
//import jakarta.persistence.TypedQuery;
//import jakarta.persistence.criteria.CriteriaBuilder;
//import jakarta.persistence.criteria.CriteriaQuery;
//import jakarta.persistence.criteria.JoinType;
//import jakarta.persistence.criteria.Predicate;
//import jakarta.persistence.criteria.Root;
//import jakarta.persistence.metamodel.EntityType;
//import jakarta.persistence.metamodel.ManagedType;
//import jakarta.persistence.metamodel.Metamodel;
//import java.util.ArrayList;
//import java.util.List;
//import java.util.Set;
//
//import static java.lang.System.out;
//import static org.junit.jupiter.api.Assertions.assertEquals;
//
//@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)
////@Sql(scripts = {"/schema-h2.sql", "/data-h2.sql"}, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
//@Sql(scripts = { "/ttl/larku/db/createVersionedDB-h2.sql",
//		"/ttl/larku/db/populateVersionedDB-h2.sql" }, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
//@DirtiesContext(classMode = ClassMode.AFTER_CLASS)
//public class DynamicCriteriaQuery {
//
//	@Autowired
//	private EntityManager em;
//
//	@Test
//	public void testBuildDynamicWithStrings() {
//		Student example = new Student();
//		example.setStatus(Student.Status.FULL_TIME);
//		buildDynamicQueryWithStringsAndQueryParams(example);
//	}
//
//
//	public void buildDynamicQueryWithStringsAndQueryParams(Student example) {
//		StringBuilder builder = new StringBuilder().append("select distinct s from Student s "
//				+ "left join fetch s.classes sc left join fetch sc.course where ");
//		if(example.getStatus() != null) {
//			builder.append(" s.status = '" + example.getStatus() + "'");
//		}else if(example.getName() != null) {
//			builder.append(" s.name like %" + example.getName() + "%");
//		}
//
//		String queryString = builder.toString();
//
//		out.println("queryString is " + queryString);
//
//		TypedQuery<Student> query = em.createQuery(queryString, Student.class);
////		query.setParameter("status", Student.Status.FULL_TIME);
//		List<Student> tqStudents = query.getResultList();
//		out.println("TQStudents: ");
//		tqStudents.forEach(System.out::println);
//		assertEquals(2, tqStudents.size());
//
//	}
//
//	@Test
//	public void testDynamicCriteria() {
//		Student example = new Student();
//		example.setStatus(Student.Status.FULL_TIME);
//		example.setName("Ana");
////		testDynamicCriteriaQuery(example);
//		testDynamicCriteriaQueryUsingMetaModel(example);
//	}
//
//	public void testDynamicCriteriaQuery(Student example) {
//		//Get the builder
//		CriteriaBuilder builder = em.getCriteriaBuilder();
//		//Create a query that will return Students
//		CriteriaQuery<Student> cq = builder.createQuery(Student.class);
//
//		//Student is also going to be the (only) root entity we will
//		//be searching from.  This need not always be the same as the
//		//type returned from the query.  This is the 'From' clause.
//		Root<Student> queryRoot = cq.from(Student.class);
//		queryRoot.fetch("classes", JoinType.LEFT); //.fetch("course", JoinType.LEFT);
//
//		//We are going to be selecting Students.
//		cq.select(queryRoot).distinct(true);
//
//		//Build up a List of jakarta.persistence.criteria.Predicate objects,
//		//based on what is not null in the example Student.
//		List<jakarta.persistence.criteria.Predicate> preds = new ArrayList<>();
//		if(example.getStatus() != null) {
//			preds.add(builder.equal(queryRoot.get("status"), example.getStatus()));
//		}
//		if(example.getName() != null) {
//			preds.add(builder.like(queryRoot.get("name"), "%" + example.getName() + "%"));
//		}
//
//		//Now 'or' them together.
//		Predicate finalPred = builder.or(preds.toArray(new jakarta.persistence.criteria.Predicate[0]));
//
//		//And set them as the where clause of our query.
//		cq.where(finalPred);
//
//		List<Student> students = em.createQuery(cq).getResultList();
//
//		out.println("Students: ");
//		students.forEach(System.out::println);
//		assertEquals(3, students.size());
//
//	}
//
//	/**
//	 * Here we are going to use the MetaModel.
//	 * 1) MetaModel is generated by Hibernate generator.  Look in
//	 *    pom.xml file for plugin and generated location.
//	 * 2) Instead of hard coded property names, we are referring to
//	 *    the properties using the MetaModel.
//	 *    e.g. Student_.name instead of "name"
//	 *    e.g. Student_.status instead of "status"
//	 *    e.g. Student_.classes instead of "classes"
//	 *
//	 * @param example
//	 */
//	public void testDynamicCriteriaQueryUsingMetaModel(Student example) {
//		//Get the builder
//		CriteriaBuilder builder = em.getCriteriaBuilder();
//		//Create a query that will return Students
//		CriteriaQuery<Student> cq = builder.createQuery(Student.class);
//
//		//Student is also going to be the (only) root entity we will
//		//be searching from.  This need not always be the same as the
//		//type returned from the query.  This is the 'From' clause.
//		Root<Student> queryRoot = cq.from(Student.class);
//		queryRoot.fetch(Student_.classes, JoinType.LEFT); //.fetch("course", JoinType.LEFT);
//
//		//We are going to be selecting Students.
//		cq.select(queryRoot).distinct(true);
//
//		//Build up a List of jakarta.persistence.criteria.Predicate objects,
//		//based on what is not null in the example Student.
//		List<jakarta.persistence.criteria.Predicate> preds = new ArrayList<>();
//		if(example.getStatus() != null) {
//			preds.add(builder.equal(queryRoot.get(Student_.status), example.getStatus()));
//		}
//		if(example.getName() != null) {
//			preds.add(builder.like(queryRoot.get(Student_.name), "%" + example.getName() + "%"));
//		}
//
//		//Now 'or' them together.
//		Predicate finalPred = builder.or(preds.toArray(new jakarta.persistence.criteria.Predicate[0]));
//
//		//And set them as the where clause of our query.
//		cq.where(finalPred);
//
//		List<Student> students = em.createQuery(cq).getResultList();
//
//		out.println("Students: ");
//		students.forEach(System.out::println);
//		assertEquals(3, students.size());
//
//	}
//
//
//	@PersistenceContext
//	private EntityManager entityManager;
//
//	@Test
//	public void playWithMetaModel() {
//		Metamodel metaModel = entityManager.getMetamodel();
//
//		Set<ManagedType<?>> managedTypes = metaModel.getManagedTypes();
//		for(ManagedType<?> mt : managedTypes) {
//			out.println("ManagedType: " + mt);
//		}
//
//		Set<EntityType<?>> entityTypes = metaModel.getEntities();
//		for(EntityType<?> mt : entityTypes) {
//			out.println("EntityType: " + mt);
//		}
//
//	}
//
//}
